{
    "collab_server" : "",
    "contents" : "---\ntitle: \"R4DS\"\nauthor: \"Hennie Bezuidenhout\"\ndate: \"03 October 2016\"\noutput: word_document \n---\n# Programming in R Studio - Pipes\n## The point of the **Pipe** is to help us read our code in an easy to understand way!!\n### magrittr package - but all packages in tidyverse automatiically make \n\nWhen are we better off not using the *Pipe* ?\n\n (@) When **Pipes** are longer than ten steps (Rather create intermediate objects with meaningful names)\n (@) We have multiple *inputs* or *outputs* (the same solution as above applies)\n (@) When we are starting to think about a *directed graph* with a complex dependency structure\n \nRemember that the``%T>%``can assist us with more complex *Pipes* \n-Effectively, the **T-Pipe** returns the left-hand side instead of the right-hand side incase we want to plot or print\n\n# Introducing Functions \n## Allows us to automate common tasks in a more powerful and general way than copy-and-pasting\n![We do not copy and paste](https://imaginationoverflowsw.files.wordpress.com/2010/11/anti-copy-paste.jpg)\n\nWhat are the advantages of using *functions* ?\n\n- You can give a function an evocative name that makes your code easier to understand.\n- As requirements change, you only need to update code in one place, instead of many.\n- You eliminate the chance of making incidental mistakes when you copy and paste (i.e. updating a variable name in one place, but not in another)\n\n##### We should seriously consider writing a `function` whenever we have copied and pasted a block of code more than **TWICE**\n\nThere are 3 steps to creating a new *function* ?\n\n- You need to pick a name for the function\n- You list the inputs, or arguments, to the function inside ```function```\n- You place the code you have developed in **body** of the function\n\n```rescale01 <- function(x) {\n  rng <- range(x, na.rm = TRUE)\n  (x - rng[1]) / (rng[2] - rng[1])\n}```\n\nMost important attribute of functions: ** WE DO NOT WANT TO REPEAT OURSELVES**\n\n## Conditional Execution\nAn ```if``` statement allows us to conditionally execute code\n```{r\nif (condition) {\n# code executed when the condition is **TRUE**\n}\nelse {\n# code executed when the condition is **FALSE**\n}\n\n```\nThe ```condition``` must evaluate to ```TRUE``` or ```FALSE```\n\nBoth ```if``` and ```function``` should (almost) always be followed up by squiggly brackets, except for very short easy to understand ```if``` statements\n\n## Function Arguments\nThe arguments to a function typically fall into two broad sets: one set supplies the **DATA** to compute on, and the other supplies arguments that control the ***details*** of the computation\n\nGenerally, data arguments should come first, and detail arguments should go on the end *and usually should have default arguments*\n\n##### Simple Example\n\nmean_ci <- function(x, conf = 0.95) {\n  >se <- sd(x) / sqrt(length(x)) **(This is DATA)**\n  alpha <- 1 - conf **(This is DATA)**\n  mean(x) + se * qnorm(c(alpha / 2, 1 - alpha / 2)) (This is detailed arguments to manupilate the DATA)\n}\n\n\n# Vectors\n\nThere are 2 main types of Vectors\n\n- **Atomic Vectors** (Logical, Integer, Double, Character, Complex and Raw)\n- **Lists**\n\n*I feel that in ```dlyr``` we will work primarily with ```Tibbles``` which automatically recognizes types of Vectors upon reading the Files*\n\n# Iteration\n\nIteration addresses duplication.Why ?\n\n- It is easier to see the intend of your code\n- It is easier to respond to changes in requirements\n- We are likely to have fewer bugs because each line of code is used in more places\n\n**Iteration** helps us to do the same thing to multiple inputs: Repeating the same operation on different columns, or on different datasets.\n\n*How will we be able to get the mean for each of the below columns ?*\n\n```{r}\n\nlibrary(knitr)\ndf <- tibble::tibble(\n  a = rnorm(10),\n  b = rnorm(10),\n  c = rnorm(10),\n  d = rnorm(10)\n)\nkable(df)\n```\n\n```\noutput <- vector(\"double\", ncol(df))  # 1. output\nfor (i in seq_along(df)) {            # 2. sequence\n  output[[i]] <- median(df[[i]])      # 3. body\n}\noutput\n#> [1] -0.2458 -0.2873 -0.0567  0.1443\n\n```\n\nEvery loop has 3 components:\n\n- The OUTPUT:``` output <- vector(\"double\", ncol(df))``` Before we start the loop, we must always allocate sufficient space for the output (This increases the speed at which the loop will be able to operate)\n- The SEQUENCE: ``` for (i in seq_along(df))```. This determines what to loop over. Each rum of the for loop will assign *i* to a different value from ``` seq_along(df)``` \n- the BODY: ```output[[i]] <- median(df[[i]``` This is the code that does the work. It runs repeatedly, each time with a different value for *i*. The first iteration will run ```output[[1]] <- median(df[[1]])```, the second will run ```output[[2]] <- median(df[[2]])```, and so on.\n\n##### Exercise Exercise Exercise Exercise \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "created" : 1475481203495.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3380055173",
    "id" : "C56F4D00",
    "lastKnownWriteTime" : 1475505249,
    "last_content_update" : 1475505249665,
    "path" : "~/GitHub/R4DS_LearnigCurve/Summary/Outline.RMD",
    "project_path" : "Outline.RMD",
    "properties" : {
        "tempName" : "Untitled2"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}
---
title: "R4DS"
author: "Hennie Bezuidenhout"
date: "03 October 2016"
output: word_document 
---
# Programming in R Studio - Pipes
## The point of the **Pipe** is to help us read our code in an easy to understand way!!
### magrittr package - but all packages in tidyverse automatiically make 

When are we better off not using the *Pipe* ?

 (@) When **Pipes** are longer than ten steps (Rather create intermediate objects with meaningful names)
 (@) We have multiple *inputs* or *outputs* (the same solution as above applies)
 (@) When we are starting to think about a *directed graph* with a complex dependency structure
 
Remember that the``%T>%``can assist us with more complex *Pipes* 
-Effectively, the **T-Pipe** returns the left-hand side instead of the right-hand side incase we want to plot or print

# Introducing Functions 
## Allows us to automate common tasks in a more powerful and general way than copy-and-pasting
![We do not copy and paste](https://imaginationoverflowsw.files.wordpress.com/2010/11/anti-copy-paste.jpg)

What are the advantages of using *functions* ?

- You can give a function an evocative name that makes your code easier to understand.
- As requirements change, you only need to update code in one place, instead of many.
- You eliminate the chance of making incidental mistakes when you copy and paste (i.e. updating a variable name in one place, but not in another)

##### We should seriously consider writing a `function` whenever we have copied and pasted a block of code more than **TWICE**

There are 3 steps to creating a new *function* ?

- You need to pick a name for the function
- You list the inputs, or arguments, to the function inside ```function```
- You place the code you have developed in **body** of the function

```rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}```

Most important attribute of functions: ** WE DO NOT WANT TO REPEAT OURSELVES**

## Conditional Execution
An ```if``` statement allows us to conditionally execute code
```{r
if (condition) {
# code executed when the condition is **TRUE**
}
else {
# code executed when the condition is **FALSE**
}

```
The ```condition``` must evaluate to ```TRUE``` or ```FALSE```

Both ```if``` and ```function``` should (almost) always be followed up by squiggly brackets, except for very short easy to understand ```if``` statements

## Function Arguments
The arguments to a function typically fall into two broad sets: one set supplies the **DATA** to compute on, and the other supplies arguments that control the ***details*** of the computation

Generally, data arguments should come first, and detail arguments should go on the end *and usually should have default arguments*

##### Simple Example

mean_ci <- function(x, conf = 0.95) {
  >se <- sd(x) / sqrt(length(x)) **(This is DATA)**
  alpha <- 1 - conf **(This is DATA)**
  mean(x) + se * qnorm(c(alpha / 2, 1 - alpha / 2)) (This is detailed arguments to manupilate the DATA)
}


# Vectors

There are 2 main types of Vectors

- **Atomic Vectors** (Logical, Integer, Double, Character, Complex and Raw)
- **Lists**

*I feel that in ```dlyr``` we will work primarily with ```Tibbles``` which automatically recognizes types of Vectors upon reading the Files*

# Iteration

Iteration addresses duplication.Why ?

- It is easier to see the intend of your code
- It is easier to respond to changes in requirements
- We are likely to have fewer bugs because each line of code is used in more places

**Iteration** helps us to do the same thing to multiple inputs: Repeating the same operation on different columns, or on different datasets.

*How will we be able to get the mean for each of the below columns ?*

```{r}

library(knitr)
df <- tibble::tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)
kable(df)
```

```
output <- vector("double", ncol(df))  # 1. output
for (i in seq_along(df)) {            # 2. sequence
  output[[i]] <- median(df[[i]])      # 3. body
}
output
#> [1] -0.2458 -0.2873 -0.0567  0.1443

```

Every loop has 3 components:

- The OUTPUT:``` output <- vector("double", ncol(df))``` Before we start the loop, we must always allocate sufficient space for the output (This increases the speed at which the loop will be able to operate)
- The SEQUENCE: ``` for (i in seq_along(df))```. This determines what to loop over. Each rum of the for loop will assign *i* to a different value from ``` seq_along(df)``` 
- the BODY: ```output[[i]] <- median(df[[i]``` This is the code that does the work. It runs repeatedly, each time with a different value for *i*. The first iteration will run ```output[[1]] <- median(df[[1]])```, the second will run ```output[[2]] <- median(df[[2]])```, and so on.

##### Exercise Exercise Exercise Exercise 

*mtcars is a preloaded dataset in R*

- Let us compute the mean for this dataset via looping across the respective columns

```{r}
View(mtcars)

firstever <- vector("double", ncol(mtcars))
for (i in seq_along(mtcars)) {
  
  firstever[[i]] <- median(mtcars[[i]])
}

firstever

## It would be nice if I manage to show the Results in a Table format 

```

*Iris is a preloaded dataset in R*

-Let us compete the number of unique observations in every column

```{r}

View(iris)

uniquely <- vector("integer",ncol(iris))
for (i in seq_along(iris)) {
  
  uniquely[[i]] <- length(unique(iris[[i]]))
  
}

uniquely

## I like this

```

There are four variations to the basic for loop

- Modifying an existing object, instead of creating a new object
- Looping over names or values, instead of indices
- Handling outputs of unknown length
- Handling sequences of unknown length

We need to analyse the ```while``` loop in more detail. I am not entirely sure how often we will be using it, but the R4DS only briefly touches on it. **I've openend up an ISSUE for this**


### For loops vs. functionals

For loops are not as important in R as they are in other languages because R is a functional programming language. 
*This means that it is possible to wrap up for loops in a function, and CALL that function instead of using the for loop directly*

One of the behaviours that makes R a functional programming language is the idea of passing a function to another function.

```
f1 <- function(x) abs(x - mean(x)) ^ 1
f2 <- function(x) abs(x - mean(x)) ^ 2
f3 <- function(x) abs(x - mean(x)) ^ 3

```

##### This can be rewritten as:

```
f <- function(x, i) abs(x - mean(x)) ^ i

```

##### Similarly:

```
col_mean <- function(df) {
  output <- vector("double", length(df))
  for (i in seq_along(df)) {
    output[i] <- mean(df[[i]])
  }
  output
}

col_median <- function(df) {
  output <- vector("double", length(df))
  for (i in seq_along(df)) {
    output[i] <- median(df[[i]])
  }
  output
}


col_sd <- function(df) {
  output <- vector("double", length(df))
  for (i in seq_along(df)) {
    output[i] <- sd(df[[i]])
  }
  output
}
```

##### This can be rewritten as:
```
col_summary <- function(df, fun) {
  out <- vector("double", length(df))
  for (i in seq_along(df)) {
    out[i] <- fun(df[[i]])
  }
  out
}
```

#### In which case we can simply call the function and specify the "calculation" needed going forward:

```
col_summary(df, median)
#> [1]  0.237 -0.218  0.254 -0.133
col_summary(df, mean)
#> [1]  0.2026 -0.2068  0.1275 -0.0917

```

Let us next discuss ```purr``` package which provides functions that eliminate the need for many common loops. The ```apply``` family of functions in base R solve a similar problem, but ```purr``` is more consistent and thus easier to learn. 

The goal of using ```purrr``` functions instead of for loops is to allow you break common list manipulation challenges into independent pieces:

- How can you solve the problem for a single element of the list? Once you’ve solved that problem, ```purrr``` takes care of generalising your solution to every element in the list.

- If you’re solving a complex problem, how can you break it down into bite-sized pieces that allow you to advance one small step towards a solution? With ```purrr```, you get lots of small pieces that you can compose together with the pipe.

### The MAP Functions

- ```map()``` makes a list
- ```map_lgl()``` makes a logical vector
- ```map_int()``` makes an integer vector
- ```map_dbl()``` makes a double vector
- ```map_chr()``` makes a character vector

Each function takes a vector as input, applies a function to each piece, and then returns a *new vector* that’s the same length (and has the same names) as the input. The type of the vector is determined by the **suffix** to the map function.

*Once you master these functions, you’ll find it takes much less time to solve iteration problems. But you should never feel bad about using a for loop instead of a map function. The map functions are a step up a tower of abstraction, and it can take a long time to get your head around how they work. The important thing is that you solve the problem that you’re working on, not write the most concise and elegant code (although that’s definitely something you want to strive towards!).*

### This is incredible!!!

```{r}

library(purrr)


map_dbl(mtcars, mean)

MyIllusiveTable <- map_dbl(mtcars, mean)

print(MyIllusiveTable)

```

### This is incredible!!!


What are the differences between ```map()``` and ```col_summary``` ?
- All ```purr``` functions are implemented in C
- The second argument, the function to apply, can be a formula, a character vector, or an integer vector. 
- Map functions also preserves names


## Mapping over multiple arguments

```map2()``` and ```pmap()``` helps us to map over multiple related inputs

######Suppose we have 2 data lists:

```{r}
mu <- list(5, 10, -3) # Data list 1

sigma <- list(1, 5, 10) # Data list 2


```

In order to generate random distributions for these 2 vectors, we can implement ```map2()```

```{r}

map2(mu, sigma, rnorm, n = 5) %>% str() 

```

But what happens behind the scenes ?

```map2()``` generates this series of function calls:


![map](http://r4ds.had.co.nz/diagrams/lists-map2.png)






